# 대장간 V3 - 재단 최적화 알고리즘 (Algorithm Documentation)

대장간 V3는 **Guillotine Bin Packing** 알고리즘을 변형하여 목재 재단의 특성(기계적 절단 편의성, 톱날 두께 손실)을 최적화한 엔진을 사용합니다.

---

## 1. 최적화 엔진: GuillotinePacker

메인 엔진은 두 가지 전략을 실행하며, `auto`는 리핑-재적용 전략을 사용합니다.

### A. 가로 우선 모드 (Horizontal / Width-Strip)
*   **철학**: "동일 폭 스트립 단위로 절단 편의성을 유지"
*   **로직**: 
    1.  부품을 **폭 기준**으로 그룹화합니다.
    2.  동일 폭 그룹만 하나의 '스트립(Strip)'으로 묶습니다.
    3.  스트립은 **높이 방향(짧은 쪽 기준)**으로 채웁니다.
    4.  서로 다른 폭 부품은 같은 스트립에 배치하지 않습니다.
*   **장점**: 폭 기준 스트립 절단으로 재단 순서가 단순해집니다.

### B. 리핑-재적용 모드 (Rip-Reapply, Auto)
*   **철학**: "큰 스트립 먼저 확보하고 잔여를 새 판재처럼 재활용"
*   **로직 (2단계 프로세스)**:
    1.  **1차 리핑 배치**: 판재 전체에 스트립 배치를 수행합니다.  
        - 1차에서는 **상위 2개 폭/높이 그룹만** 사용합니다.  
        - 동일 폭 그룹은 **2개 묶음 스트립**(폭×2) 배치를 시도합니다.  
        - **리핑 축은 짧은 축(예: 1220 방향)을 기준**으로 선택합니다.  
    2.  **잔여 재적용**: 1차 배치 후 남은 직사각형 잔여를 **새 판재**로 보고 동일 로직을 재적용합니다.  
        - 2차부터는 **모든 그룹을 허용**합니다.
    3.  **추가 배치가 없으면 종료**합니다.
*   **의도**: 현장 작업 흐름(큰 사이즈 먼저 절단 → 잔여 활용)을 반영합니다.

### C. 자동 모드 (Auto)
`auto` 모드는 리핑-재적용 모드를 기본으로 사용합니다.  
앱 기본값도 `auto`로 설정됩니다.

---

## 2. 핵심 기술 상세

### 회전 처리 (Rotation)
회전 가능한 부품(`rotatable: true`)은 **해당 잔여 직사각형 안에서만** 회전 여부를 판단합니다.  
원본 아이템은 변경하지 않고, 배치 시점에만 회전을 적용합니다.

### 톱날 두께 (Kerf) 처리
모든 배치 계산 시 사용자가 설정한 `kerf` 값이 반영됩니다.
*   부품 사이의 간격뿐만 아니라, 판재 테두리(트리밍/전단여부)와의 간격도 정밀하게 계산합니다.
*   `neededWidth = x === 0 ? width : width + kerf` 로직을 통해 첫 부품 이후부터 손실 면적을 계산에 포함합니다.

### 치수 및 라벨링 엔진
재단 도면의 가독성을 위해 `LabelingEngine`이 별도로 작동합니다.
*   동일 규격 부품은 동일한 라벨(A, B, C...)을 부여받습니다.
*   도면 혼잡을 막기 위해 동일 라벨의 **첫 번째 부품**에만 상세 수치(`W x H`)를 표시합니다.

---

## 3. 알고리즘 제약 및 향후 과제

1.  **Nested Packing 미지원**: 현재는 기계적 절단을 위해 2단계(Level) 이상의 복잡한 중첩 배치는 지양하고 있습니다. (Guillotine Cut 보장)
2.  **나무결(Grain) 제약**: 나무결 고정 시 회전 알고리즘이 자동으로 비활성화되어 물리적 특성을 준수합니다.
3.  **리핑 축 선택**: 짧은 축 기준으로 리핑을 수행합니다. 특정 현장 규칙이 있다면 옵션화가 필요합니다.
4.  **상위 그룹 제한**: 1차 배치에서 상위 2개 그룹만 사용하므로 특정 케이스에서 작은 폭 그룹 배치가 지연될 수 있습니다.
5.  **2개 묶음 스트립**: 동일 폭 부품을 2개 묶어 폭×2 스트립을 생성합니다. 특정 케이스에서 과도한 편향이 생길 수 있습니다.

---
*Last Updated: 2026-02-04*
