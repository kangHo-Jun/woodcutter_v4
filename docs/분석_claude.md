# 대장간 V4 - 버그 분석 보고서

> 분석일: 2026-02-04
> 분석 대상: `js/packer.js`, `js/main-unified.js`, `js/costCalculator.js`
> 분석 도구: 코드 정적 분석 + Node.js 시뮬레이션 실행

---

## 목차

1. [분석 요약](#1-분석-요약)
2. [Critical 버그: splice 인덱스 역순 제거 오류](#2-critical-버그-splice-인덱스-역순-제거-오류)
3. [이슈별 재현 결과](#3-이슈별-재현-결과)
4. [재단비 미노출 원인 분석](#4-재단비-미노출-원인-분석)
5. [수정 방안](#5-수정-방안)

---

## 1. 분석 요약

사용자 보고 4건의 이슈를 조사한 결과, **1건의 Critical 버그**가 3건의 이슈의 공통 원인이며, 나머지 1건(재단비 미노출)은 별도의 2가지 원인이 확인되었다.

| # | 보고된 이슈 | 근본 원인 | 심각도 |
|---|-------------|-----------|--------|
| 1 | 400x300 35개 가로우선: 패턴3 조각이 패턴2에 들어갈 수 있음 | **splice 버그** (아이템 복제) | Critical |
| 2 | 400x300 35개 자동: 동일 증상 | **splice 버그** (아이템 복제) | Critical |
| 3 | 혼합사이즈 자동: 패턴7 조각이 패턴2에 들어갈 수 있음 | **splice 버그** (아이템 복제) | Critical |
| 4 | 재단비가 표시되지 않는 경우 발생 | DOM 요소 누락 + 0원 계산 | Medium |

---

## 2. Critical 버그: splice 인덱스 역순 제거 오류

### 2.1 버그 위치

**동일한 버그가 2곳에 존재한다:**

- `js/packer.js` **256행** — `StripBin.packStrips()` 내부
- `js/packer.js` **364행** — `StripEfficiencyBin.packWithStrips()` 내부

### 2.2 문제 코드

```javascript
// 스트립에 배치된 아이템들을 groupItems에서 제거하는 코드
for (let i = placedInStrip.length - 1; i >= 0; i--) {
    groupItems.splice(placedInStrip[i], 1);
}
```

### 2.3 버그 메커니즘 상세 설명

#### 배경: placedInStrip 배열의 구조

스트립에 아이템을 배치하는 루프는 **역방향**(높은 인덱스 → 낮은 인덱스)으로 순회한다:

```javascript
for (let i = groupItems.length - 1; i >= 0; i--) {
    // i = 34, 33, 32, ... 순서로 순회
    if (currentX + neededWidth <= this.width) {
        // 배치 성공 시 인덱스 기록
        placedInStrip.push(i);
    }
}
```

35개의 동일 부품(400x300)이 있을 때, 한 스트립에 6개가 배치되면:

```
placedInStrip = [34, 33, 32, 31, 30, 29]   ← 내림차순
```

#### 버그가 발생하는 과정

제거 루프가 `placedInStrip`을 **역순 순회**하므로 실제 splice 순서는 **오름차순**이 된다:

```
반복 1: placedInStrip[5] = 29 → splice(29, 1)   ✅ 정상 (길이 35→34)
반복 2: placedInStrip[4] = 30 → splice(30, 1)   ⚠️  원래 인덱스31의 아이템 제거
반복 3: placedInStrip[3] = 31 → splice(31, 1)   ⚠️  원래 인덱스33의 아이템 제거
반복 4: placedInStrip[2] = 32 → splice(32, 1)   ❌ 배열 길이=32, 인덱스 초과! 무효
반복 5: placedInStrip[1] = 33 → splice(33, 1)   ❌ 무효
반복 6: placedInStrip[0] = 34 → splice(34, 1)   ❌ 무효
```

**핵심 원인**: `splice()`로 앞쪽 원소를 제거하면 뒤쪽 원소의 인덱스가 1씩 감소한다. 그런데 이후 splice에서는 원래 인덱스를 그대로 사용하므로, 잘못된 위치를 제거하거나 배열 범위를 초과하여 아무것도 제거하지 못한다.

#### 수치로 보는 영향

6개를 배치하고 제거해야 하는 상황에서:

```
제거 예정: 6개
실제 제거: 3개 (29, 30의 원래아이템, 31의 원래아이템 → 결국 3개만 정확히 제거)
미제거:    3개 (유령 아이템으로 남음)
```

**스트립마다 약 50%의 아이템이 미제거되어 다음 스트립 또는 다음 판재로 넘어간다.**

#### 시각적 설명

```
[초기 상태]  groupItems: ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●  (35개)
                                                          ^^^^^^
                                                          배치된 6개 (인덱스 29~34)

[정상 동작]  groupItems: ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●          (29개)
                         → 6개가 정확히 제거됨

[실제 동작]  groupItems: ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●       (32개)
                         → 3개만 제거됨, 3개의 유령 아이템이 남아있음
```

### 2.4 연쇄 효과: 아이템 복제 → 판재 폭증

이 미제거 아이템(유령 아이템)은 다음 스트립에서 **다시 배치**된다. 그리고 그 스트립에서도 같은 splice 버그가 발생하여 또 유령 아이템이 남는다. 이 과정이 모든 스트립, 모든 판재에서 반복된다.

```
[Bin 1]
  입력: 35개
  Strip 1: 6개 배치, 3개 미제거 → groupItems = 32
  Strip 2: 6개 배치, 3개 미제거 → groupItems = 29
  Strip 3: 6개 배치, 3개 미제거 → groupItems = 26
  Strip 4: 6개 배치, 3개 미제거 → groupItems = 23
  → Strip 5 공간 부족 → 23개가 unplaced로 이동
  → 배치: 24개, 반환 unplaced: 23개 (합계 47, 원래 35에서 12개 복제됨)

[Bin 2]
  입력: 23개 (실제로는 11개여야 함)
  → 같은 패턴 반복... 24개 배치, 11개 unplaced

[Bin 3]
  입력: 11개
  → 19개 배치, 1개 unplaced

[Bin 4]
  입력: 1개
  → 1개 배치
```

**결과: 35개 부품에 4장의 판재 사용 (정상은 2장)**

---

## 3. 이슈별 재현 결과

Node.js에서 `packer.js`를 직접 실행하여 시뮬레이션한 결과이다.

### 3.1 이슈 1: 400x300 35개, 가로우선 모드

**판재: 2440 x 1220mm, kerf: 4.2mm**

#### 버그 상태 (현재)

| 판재 | 배치 수 | 효율 | 비고 |
|------|---------|------|------|
| Bin 1 | 24 | 96.7% | |
| Bin 2 | 24 | 96.7% | 유령 아이템 포함 |
| Bin 3 | 19 | 76.6% | 유령 아이템 포함 |
| **Bin 4** | **1** | **4.0%** | **1개를 위해 판재 1장 낭비** |

- 총 판재: **4장**, 고유 패턴: **3개**
- 사용자 보고와 일치: "패턴3의 조각이 패턴2에 들어갈 수 있는데 쓸데없는 판재가 소비"

#### 수정 후

| 판재 | 배치 수 | 효율 |
|------|---------|------|
| Bin 1 | 24 | 96.7% |
| Bin 2 | 11 | 44.3% |

- 총 판재: **2장**, 고유 패턴: **2개**
- **판재 2장 절약** (50% 감소)

### 3.2 이슈 2: 400x300 35개, 자동 모드

#### 버그 상태 (현재)

| 모드 | 판재 수 | 선택됨 |
|------|---------|--------|
| 가로우선 | 4장 | |
| 스트립효율 | 3장 | ✅ (적으므로) |

- 자동모드에서 스트립효율이 선택됨 (3장 < 4장)
- 하지만 3장도 **버그로 인한 과다** 사용

#### 수정 후

| 모드 | 판재 수 | 선택됨 |
|------|---------|--------|
| 가로우선 | 2장 | ✅ (동일하므로 가로우선 우선) |
| 스트립효율 | 2장 | |

- 양쪽 모두 **2장**으로 동일, 절단 편리한 가로우선 선택
- **판재 1장 절약** (33% 감소)

### 3.3 이슈 3: 혼합사이즈 (1000x800 x9, 910x650 x9, 530x450 x9), 자동 모드

#### 버그 상태 (현재)

```
총 27개 부품 → 18장 판재 사용 (7개 고유 패턴)

패턴 1: 1000x800 x2         ← 8장 동일
패턴 2: 1000x800 x1         ← 1장
패턴 3: 910x650 x2 + 530x450 x4  ← 3장 동일
패턴 4: 910x650 x2 + 530x450 x3  ← 1장
패턴 5: 910x650 x2 + 530x450 x1  ← 1장
패턴 6: 910x650 x2              ← 3장 동일
패턴 7: 910x650 x1              ← 1장   ★ 이것이 패턴2 여유공간에 들어갈 수 있음
```

- 사용자 보고와 일치: "패턴7의 조각이 패턴2에 들어갈 수 있는데 쓸데없는 판재가 소비"

#### 수정 후

```
총 27개 부품 → 10장 판재 사용 (6개 고유 패턴)

패턴 1: 1000x800 x2              ← 4장 동일
패턴 2: 1000x800 x1              ← 1장
패턴 3: 910x650 x2 + 530x450 x4  ← 2장 동일
패턴 4: 910x650 x2 + 530x450 x1  ← 1장
패턴 5: 910x650 x2               ← 1장
패턴 6: 910x650 x1               ← 1장
```

- **8장 절약** (44% 감소)
- 패턴 수: 7 → 6

> **참고**: 수정 후에도 1000x800 부품은 판재당 2개만 배치 가능하다 (800 + 4.2 + 800 = 1604.2 > 1220). 이것은 스트립 기반 알고리즘의 구조적 한계이며, 버그가 아니다. 1000x800 옆의 남은 공간(431.6mm)에 다른 부품이 들어가려면 Nested Packing이 필요하다.

---

## 4. 재단비 미노출 원인 분석

### 4.1 원인 A: `materialUsageRate` DOM 요소 누락으로 인한 크래시

**위치**: `js/main-unified.js` 1274행

```javascript
// 새 프로젝트 리셋 시 실행되는 코드
document.getElementById('totalPanelCount').textContent = '-';   // ✅ 존재함
document.getElementById('totalCutCount').textContent = '-';     // ✅ 존재함
document.getElementById('totalCuttingCost').textContent = '-';  // ✅ 존재함
document.getElementById('materialUsageRate').textContent = '-'; // ❌ index.html에 없음!
```

**영향 분석:**

- `materialUsageRate` 요소는 구버전(`index-pc-old.html`)에만 존재하고, 현재 `index.html`에는 없다
- `document.getElementById('materialUsageRate')`가 `null`을 반환
- `null.textContent = '-'`에서 **TypeError** 발생
- 이 에러 이후의 코드가 실행되지 않음:
  - 라벨 그룹 목록 초기화 안됨
  - 캔버스 스크롤 컨테이너 정리 안됨
  - `groupCanvases` 배열 초기화 안됨

**재현 조건**: "새 프로젝트" 버튼 클릭 시 항상 발생

**재단비와의 관계**: 직접적으로 재단비 미노출을 유발하지는 않지만, 리셋이 불완전하여 이전 결과가 UI에 잔류할 수 있다. 이 상태에서 다시 계산하면 이전 캔버스와 새 결과가 혼재될 수 있다.

### 4.2 원인 B: splice 버그로 인한 판재 수 증가 → 재단비 0원

**메커니즘:**

```
판재 수 증가 (splice 버그)
    ↓
trimCuts = panelCount × 4   (트리밍 활성화 시)
    ↓
판재가 많아지면 trimCuts가 totalCuts보다 커질 수 있음
    ↓
billableCuts = max(0, totalCuts - trimCuts) = 0
    ↓
totalCuttingCost = 0 × cutPrice = 0
    ↓
화면에 "0원" 표시 → 사용자에게 "미노출"로 인식
```

**예시** (400x300 35개, 트리밍 활성화):

| 항목 | 버그 상태 | 수정 후 |
|------|-----------|---------|
| 판재 수 | 4장 | 2장 |
| trimCuts | 16 (4×4) | 8 (2×4) |
| totalCuts | 약 14~20회 | 약 14회 |
| billableCuts | 0~4회 | 6회 |
| 재단비 (1500원/회) | **0~6,000원** | **9,000원** |

트리밍 활성화 시 버그로 인한 과도한 판재 수가 trimCuts를 높여, 실제 청구 절단 횟수가 0이 되는 경우가 발생한다.

### 4.3 원인 C: 계산 실패 시 early return

**위치**: `js/main-unified.js` 565~569행

```javascript
if (result.unplaced.length > 0) {
    alert(`${result.unplaced.length}개의 부품을 배치할 수 없습니다.`);
    return;  // ← displayResults()가 호출되지 않음
}
```

부품이 판재보다 클 때 등 배치 불가 시, 재단비 표시 함수가 호출되지 않는다. 이전 값('-' 또는 이전 계산 결과)이 그대로 남는다.

---

## 5. 수정 방안

### 5.1 [Critical] splice 순서 수정 — `packer.js` 2곳

**수정 원리**: `placedInStrip`은 내림차순(34, 33, 32...)으로 저장되어 있으므로, **정방향 순회**(0부터)하면 높은 인덱스부터 제거하게 되어 인덱스 밀림 문제가 없다.

**StripBin (256행):**

```javascript
// AS-IS (버그)
for (let i = placedInStrip.length - 1; i >= 0; i--) {
    groupItems.splice(placedInStrip[i], 1);
}

// TO-BE (수정)
for (let i = 0; i < placedInStrip.length; i++) {
    groupItems.splice(placedInStrip[i], 1);
}
```

**StripEfficiencyBin (364행):** 동일한 수정 적용.

### 5.2 [Medium] materialUsageRate null 참조 수정 — `main-unified.js` 1274행

```javascript
// AS-IS (크래시)
document.getElementById('materialUsageRate').textContent = '-';

// TO-BE (안전한 처리)
const materialUsageRate = document.getElementById('materialUsageRate');
if (materialUsageRate) materialUsageRate.textContent = '-';
```

또는 해당 행을 삭제한다 (현재 UI에서 사용률 표시 영역이 없으므로).

### 5.3 검증 방법

수정 후 아래 시나리오를 테스트하여 검증한다:

| # | 테스트 케이스 | 기대 결과 |
|---|---------------|-----------|
| 1 | 400x300 35개, 가로우선 | 2장, 패턴 2개 |
| 2 | 400x300 35개, 자동 | 2장, 패턴 2개 |
| 3 | 1000x800 x9 + 910x650 x9 + 530x450 x9, 자동 | 10장, 패턴 6개 |
| 4 | 위 테스트들에서 총 배치 수 = 입력 수량 확인 | 35개, 27개 |
| 5 | 트리밍 활성화 후 재단비가 0원이 아닌지 확인 | 재단비 > 0 |
| 6 | "새 프로젝트" 클릭 후 콘솔에 에러 없는지 확인 | TypeError 없음 |

---

## 6. 신규 알고리즘 확정안 (2단계 리핑-재적용)

### 6.1 목표

현장에서의 작업 흐름을 사전에 시뮬레이션하여 절단 계획에 반영한다.

```
1차 가공으로 배치 확정
→ 남은 직사각형 잔여를 추출
→ 잔여를 "새 판재"로 간주
→ 잔여 치수에 맞는 미배치 부품을 다시 배치
→ 더 이상 배치가 없으면 종료
```

### 6.2 확정된 규칙

1. 리핑 방향: 높이 방향(짧은 쪽, 예: 1220)을 기준으로 스트립 생성
2. 스트립 폭 선택: 폭 빈도 많은 순
3. 2단계 대상: 미배치 부품만 사용
4. 잔여 영역 처리 순서: 면적 큰 것부터
5. 트리밍: 사용하지 않음 (kerf만 적용)
6. 회전/나무결: 1단계 조건과 동일하게 유지
7. 자동 모드: 위 2단계 리핑-재적용을 기본 전략으로 사용
8. 가로우선 모드: 폭이 동일한 경우에만 배치 (동일 폭 스트립 내 배치)

### 6.3 설계 포인트 (코딩 준비)

1. 1차 배치 후 `freeRects`를 직사각형으로 유지
2. 각 `freeRect`를 새 판재로 보고 동일 로직 재적용
3. 재적용 과정에서 추가 배치가 0개면 종료
4. `kerf`는 모든 단계에서 동일 적용

---

*Last Updated: 2026-02-04*
